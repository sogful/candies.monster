<!DOCTYPE html>
<html lang="en">
<head>

    <title>raw2png</title>
    <link rel="icon" type="image/png" href="/assets/images/icon/frame1.png">

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <meta property="og:image" content="/assets/images/banner.png">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="/assets/images/banner.png">

    <!-- search engines (practically no one is gonna find this through google but still) -->
    <meta name="robots" content="index, follow, max-snippet:120, max-image-preview:large, max-video-preview:5">
    <meta name="googlebot" content="index, follow, max-snippet:120, max-image-preview:large, max-video-preview:5">
    <meta name="bingbot" content="index, follow">
    <meta name="keywords" content="cut the rope, cut the rope modding, cut the rope home, level browser, game, walkthrough, tips, ios, android game">

    <style>

        @font-face {
            font-family: "Good Dog";
            src: /*universal*/ url("/assets/fonts/gooddog.woff");
        }

        body {
            font-family: "Good Dog";
            position: relative; z-index: 1;
            display: flex; justify-content: center; align-items: center;
            min-height: 100vh; min-width: 100vw; overflow: hidden;
            user-select: none; padding: 0; margin: 0;
            -webkit-user-drag: none;

            background-color: #e9a856;
            --bg: url("/assets/images/bg.webp"); /* (DON"T turn on word wrap) */
            background-image: var(--bg), url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' display='block' viewBox='0 0 2048 1154'%3E%3Cpath fill='%2392a902' d='M0 0h2048v1152l-508 1v1h-64v-1L0 1152Z'/%3E%3Cpath fill='%23d6924b' d='M0 0h2048v500l-3-1-27-1-5-3v-2l-14-1h-76l-7 2-3 2h-14v-2h-25l-13-4-4-2-17-1-8-2-7-3-7-2v-2h-25l-16-3-8-3-4-2h-10l-11 4h-15l-20-3-11-3-17-3v-2h-15l-33-2h-35l-9-4-16 1h-11l-8-5-16-3-2-1h-11l-6 1-26 1-12 2-5 5-5-1-1-1-23-1-3 1-30 1-8 3-34 1-32 2-18 4-8 3-16 2-19 3h-13l-16-4-9 1-7 3-12 1-6 2-25 1-6 3-7 2-7 3-5 1-16 1-17 6-25 1h-14l-3-3-3-1h-80l-13 2-7 4-24 1-10 5-30 1-21 3-6 2-20 3-27 6-14 4-11 2h-8l-12-3h-8l-4 2h-51l-1 1-20 2-40 1-10 5h-7l-10-1-5 4-37 1h-39l-12 2-13 5-7 1-12-5-7-2-11-2h-11l-19 1h-21l-23-2-3-3h-17l-7-2v-2l-45-1-1-1-18-2-53-1-2-1h-7l-8 3h-12l-16-4-19-3-19-5-20-4-5-2-19-3-35-1-6-3-19-1-10-2-4-3-8-2H0Z'/%3E%3Cpath fill='%235b65a6' d='M540 783h24l4 1 16 1 8 10 8 4 5 2 9 2 13 5 7 4 9 1 1 3 7 1 15 3 14 2 12 3 26 3 15 4 11 2 12 3 5 1v2l6 1 5 2 16 3 18 4 21 3 1 1 11 2 6 2 21 5 16 4 26 6 9 3 10 1 9 3 4 1 14 1 2 1 14 1 13 3 9 3 6 3 16 4 20 3 9 3 12 2 28 4 14 3 19 2 12 3 5 2 7 1 8 3 19 5 1 1 14 2 29 4 12 4 39 7 17 2 9 3 10 4 13 3 39 3 18 1 12 3 14 3 14 4 11 2 7 3 19 6 2 1 9 1 3 2 5 1 34 2 6 2 11-1 25-5 16-1 19-7 12-3 5-2 9-2 16-4 11-2 12-1 1-1 14-1 3-1 36-2 11-3h5v-2l12-3 7-3 24-3 5-2 24-4 12-3 16-2h10v-2l10-2 15-2 18-5 4-3 18-4 24-4 3-1 18-2 7-2 21-3 6-2 29-6 19-3 14-5 2-2 8-2 8-2h4v270l-508 1v1h-64v-1L0 1152V911l16-3 9-1 16-4 26-6 16-3 9-1 6-4 18-5 16-1 2-1 14-1 13-4 10-2 18-4 15-4 17-3 7-2 18-5 9-2 4-2 27-4 31-7 14-4 1-1h5v-2l16-3 16-2 1-2 9-2 15-1 12-3 15-2 23-5 14-5 5-3 10-4 8-2 28-10 21-6Z'/%3E%3Cpath fill='%23f1f2ea' d='M540 783h24l4 1 16 1 8 10 8 4 5 2 9 2 13 5 7 4 9 1 1 3 7 1 15 3 14 2 12 3 26 3 15 4 11 2 12 3 5 1v2l6 1 5 2 16 3 18 4 21 3 1 1 11 2 6 2 21 5 16 4 26 6 9 3 10 1 9 3 4 1 14 1 2 1 14 1 13 3 9 3 6 3 16 4 20 3 9 3 12 2 28 4 14 3 19 2 12 3 5 2 7 1 8 3 19 5 1 1 14 2 29 4 12 4 39 7 17 2 9 3 10 4 13 3 39 3 18 1 12 3 14 3 14 4 11 2 7 3 19 6 2 1 9 1 3 2 5 1 34 2 6 2 11-1 25-5 16-1 19-7 12-3 5-2 9-2 16-4 11-2 12-1 1-1 14-1 3-1 36-2 11-3h5v-2l12-3 7-3 24-3 5-2 24-4 12-3 16-2h10v-2l10-2 15-2 18-5 4-3 18-4 24-4 3-1 18-2 7-2 21-3 6-2 29-6 19-3 14-5 2-2 8-2 8-2h4v10l-1 1-12 1-18 6-14 5-14 2-19 1-25 4h-15l-8 3-17 2-15 6-19 5-17 4-11 3-3 1-19 1-7 1-1 3-5 3h-11l-12 6-7 2-20 1-18 2-13 2-17 3-25 5-23 3-2 2-10 4-10 5-4 3-12 1h-5l-8 4-24 1-15 2-10 2v2l-15 4-9 3h-5l-5-3h-11l-1 1h-16l-3 3-7-1-6-1-15 1-8-2v-2l-11-1-13-5-8-3-19-3-10-4-9-1-6 2-1 1h-12l-4-3-12-5-10-6-18-5-20-2-12-3-45-6-24-2-8-3-8-3-9-1-5-3v-2l-6-1-19-1-20-4-23-7-13-3-9-5-23-3-7-3-36-3-28-1-25-8-6-3-21-3-25-8-16-1-12-4-13-5-16-4-30-1-11-4-14-4-9-2-3-2-21-3-28-3-22-7-30-4-12-2-5-3-7-1-3-3h-14l-7-4-8-5-8-2-15-8-19-6-27-8v-2h-8l-12-3-10-3-16-1-8 2-20 6-25 5-17 5-9 4-10 4-10 5-13 3-5 5-10 2-11 4-10 2-16 4-25 3-29 8-14 2-20 1-16 3-9 3-16 5-9 3-5 1-20 1-15 4-18 5-12 3-3 1-17 1-17 6-3 1-16 2-8 3-17 4-9 3-13 2-16 1-5 2-33 2-8 5H0v-6l16-3 9-1 16-4 26-6 16-3 9-1 6-4 18-5 16-1 2-1 14-1 13-4 10-2 18-4 15-4 17-3 7-2 18-5 9-2 4-2 27-4 31-7 14-4 1-1h5v-2l16-3 16-2 1-2 9-2 15-1 12-3 15-2 23-5 14-5 5-3 10-4 8-2 28-10 21-6Z'/%3E%3Cpath fill='%23f7f4e9' d='M1481 445h66l31 5 20 3 27 2 12 2 52 2 2 1 21 1 16 2 48 3 27 3 23 3 12 2 22 4 26 5 2 1h22l4-1h24l21 4 10 1 38 1 11 2 1 1 29 3v5l-3-1-27-1-5-3v-2l-14-1h-76l-7 2-3 2h-14v-2h-25l-13-4-4-2-17-1-8-2-7-3-7-2v-2h-25l-16-3-8-3-4-2h-10l-11 4h-15l-20-3-11-3-17-3v-2h-15l-33-2h-35l-9-4-16 1h-11l-8-5-16-3-2-1h-11l-6 1-26 1-12 2-5 5-5-1-1-1-23-1-3 1-30 1-8 3-34 1-32 2-18 4-8 3-16 2-19 3h-13l-16-4-9 1-7 3-12 1-6 2-25 1-6 3-7 2-7 3-5 1-16 1-17 6-25 1h-14l-3-3-3-1h-80l-13 2-7 4-24 1-10 5-30 1-21 3-6 2-20 3-27 6-14 4-11 2h-8l-12-3h-8l-4 2h-51l-1 1-20 2-40 1-10 5h-7l-10-1-5 4-37 1h-39l-12 2-13 5-7 1-12-5-7-2-11-2h-11l-19 1h-21l-23-2-3-3h-17l-7-2v-2l-45-1-1-1-18-2-53-1-2-1h-7l-8 3h-12l-16-4-19-3-19-5-20-4-5-2-19-3-35-1-6-3-19-1-10-2-4-3-8-2H0v-9l20 1 7 3 60 1 11 3 26 3 3 1 13 1 3 1 15 1 30 4 36 5 21 3 31 3 60 6 45 2 11 1 2 1 22 1 3 1 32 1 14 2 32 1 31 3 12 2 10-1 15-4 17-4 3-2h7l9 3 5 1h18l9-1 36-1 3-1 22-1 24-4 23-2 21-1 26-4 21-2 23-1 14-2 22-1 4-1 17-1 13-3 20-2 7-1 18-1 2-1 25-2 4-2 22-2v-2l60-1 8-3h50l24-7 14-4 19-3 7-2 33-4 1-1 65-4 13-2h41l21-2 40-2 2-1 38-2 29-4Z'/%3E%3C/svg%3E");
            
            background-position: center center;
            background-repeat: no-repeat; background-size: cover;

            cursor: url("/assets/static/idle.cur"), default !important;
        }
        body:active, body:focus, body:focus-within, body:target, body:active * {
            cursor: url("/assets/static/active.cur"), default !important;
        }
        :any-link {
            color: #8feeff; text-decoration: none !important;
            cursor: url("/assets/static/link.cur"), default !important;
        }
        * {
            cursor: inherit !important; 
            scrollbar-width: none; scrollbar-color: #ffffff #ffffff;
        }
        *::-webkit-scrollbar {width: 0px}
        a {margin: 0.3em}

        .splitwarn {
            position: fixed; display: none; flex-direction: column;
            justify-content: center; align-items: center; text-align: center;
            width: 100vw; height: 100vh; z-index: 65535;
            background-color: rgba(0,0,0,0.5); 
            filter: drop-shadow(0 4px 12px rgba(0,0,0,0.33));
            transition: opacity 0.5s;
        }
        .splitwarn a {
            color: white; margin-left: 20%; margin-right: 20%;
            -webkit-text-stroke: 0.175em black;
            text-shadow: 0 0.15em 0 black;
            paint-order: stroke fill;
        }
        .splitwarn label {
            font-size: 2em;
            color: white;
            -webkit-text-stroke: 0.175em black;
            text-shadow: 0 0.15em 0 black;
            paint-order: stroke fill;
        }

        /*//////////////////////////////////////////////////////////////////////*/

        .page {
            display: flex; flex-direction: column;
            justify-content: center; align-items: center; text-align: center;
            width: min(90vw, 700px); height: 90vh;
            color: white; font-size: 1.5em;
            -webkit-text-stroke: 0.175em black;
            text-shadow: 0 0.15em 0 black;
            paint-order: stroke fill;
        }

        .title {
            font-size: 3em;
            -webkit-text-stroke: 0.125em black;
            text-shadow: 0 0.1em 0 black;
            paint-order: stroke fill;
        }
        .subtitle {
            font-size: 2em;
            -webkit-text-stroke: 0.15em black;
            text-shadow: 0 0.1em 0 black;
            paint-order: stroke fill;
        }
        .tiny {
            font-size: 0.5em !important;
        }

        /*//////////////////////////////////////////////////////////////////////*/

        .buttons {
            display: flex; gap: 1em;
            flex-wrap: wrap; justify-content: center;
        }
        .button {
            display: flex;  position: relative;
            flex-direction: column; align-items: center;
            cursor: pointer; background: none;
            border: none; padding: 0;
        }
        .button img {height: 2.5em}
        input {display: none}

        .button span {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #fff; font-size: 1em;
            pointer-events: none;
            white-space: nowrap; user-select: none;
        }

        /*//////////////////////////////////////////////////////////////////////*/
        
        .stats {
            display: none; position: fixed; flex-direction: column;
            align-items: center; overflow: hidden !important;
            gap: 0.25em; bottom: 1em;
        }
        .progressinfo {font-size: 0.8em}

        .errorconsole {
            display: none; overflow: hidden !important;
            margin-top: 0.75em;
            width: min(90vw, 700px);
            max-width: 90vw;
        }
        .errortitle {
            font-size: 0.9em;
            margin-bottom: 0.25em;
        }
        .errors {
            background: rgba(0,0,0,0.25); color: #fff;
            font-size: 0.8em; overflow: hidden !important;
            text-shadow: none; padding: 0.5em;
            min-height: 10vh; max-height: 30vh;
            overflow: auto; white-space: pre-wrap; border-radius: 1em;
        }
    </style>
    
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.28.3/full/pyodide.js"></script>

</head>
<body>
    
    <audio class="click" src="/assets/audio/tap.mp3" preload="auto"></audio>

    <div class="splitwarn">
        <a class="title" style="color:#f08b8b">Warning!</a>
        <a class="subtitle">This game version is likely old and will not return correct sprites. Split files have odd colorspace data that's not implemented yet.</a>
        <label class="button clickable" onclick="document.querySelector('.splitwarn').style.display = 'none'">
            <span>Ok</span>
            <img src="/levels/assets/images/buttons/sbutton.webp" draggable="false">
        </label>
    </div>

    <div class="page">
        <a class="title">raw2png</a>
        <span style="padding-bottom: 0.5em">Sprites in most of the Cut the Rope games for mobile are compressed, making them difficult to extract.
        <br>
        This tool attempts to do the <i>zstd/zlib</i> decompression in the comfort of your browser to avoid that headache.
        <br></i></span>

        <span class="tiny">For .xnb sprites, see<a href="https://github.com/LeonBlade/xnbcli">xnbcli</a>or<a href="https://lybell-art.github.io/xnb-js/">Web XNB Converter.</a></span>
        <span class="tiny">For .xnb audio, see<a href="//candies.monster/assets/static/XNBSoundConverter.exe">XNBSoundConverter</a>(to wav) and<a href="https://github.com/JavidPack/WAVToXNBSoundConverter">WAVToXNBSoundConverter</a>(to xnb). You can also directly play and convert .xnb audio with <a href="https://vgmstream.org/">vgmstream.</a></span>

        <a class="subtitle">Select:</a>
         <div class="buttons">
            <label class="button clickable">
                <input class="inputfolder" type="file" webkitdirectory directory multiple accept=".raw" class="hiddeninput">
                <img src="/levels/assets/images/buttons/sbutton.webp" draggable="false">
                <span>Folder</span>
                <span class="tiny" style="padding-top: 6.5em">+ subfolders</span>
            </label>
            <a>or</a>
            <label class="button clickable">
                <input class="inputsingle" type="file" accept=".raw" class="hiddeninput">
                <img src="/levels/assets/images/buttons/sbutton.webp" draggable="false">
                <span>Single file</span>
            </label>
        </div>
        <span class="tiny"><br><br>IOS, large and split (.raw1 - .raw8) files do not work yet. Please<a href="https://github.com/sogful/candies.monster">contribute</a>if you have a solution!</span>

        <div class="stats">
            <div class="counts"><a style="color:#6cf16c">0 success</a>//<a style="color:#fff457">0 warnings</a>//<a style="color:#f08b8b">0 failed</a></div>
            <div class="progressinfo">Starting…</div>
        </div>

        <div class="errorconsole">
            <div class="errortitle">Errors</div>
            <div class="errors"></div>
        </div>
    </div>
    <script>

        const favicons = Array.from({length: 20}, (_, i) => `/assets/images/icon/frame${i + 1}.png`);
        let index = 0; const delay = 300;
        function favicongif() {
            const link = document.querySelector("link[rel='icon']") || document.createElement("link");
            link.rel = "icon";
            link.href = favicons[index];
            document.head.appendChild(link);
            index = (index + 1) % favicons.length;
            setTimeout(favicongif, delay);
        }; favicongif();

        // click sfx
        document.querySelectorAll(".clickable").forEach(function(element) {
            element.addEventListener("click", function() {
                document.querySelector(".click").currentTime = 0;
                document.querySelector(".click").play();
            });
        });

        /* wobblenah scrapped - https://codepen.io/queenadreena/pen/oKGyYq
        const all = document.querySelectorAll(".wobble");
        all.forEach(el => {
            let text = el.textContent; text = text.split("");
            const textcode = text.map((x, idx) => {
                let delay = (idx + 1) * 50;
                return `<span style="animation-delay: ${delay}ms">${x}</span>`;
            }); el.innerHTML = textcode.join("");
        }); */

        /*//////////////////////////////////////////////////////////////////////*/

         (function(){
             
             const progressinfo = document.querySelector(".progressinfo");
             const errors = document.querySelector(".errors");

            let firstshown = false;
            let splitwarnshown = false;
            let pyready = null;

            function showstats(){
                if (!firstshown){
                    document.querySelector(".stats").style.display = "flex";
                    document.querySelector(".errorconsole").style.display = "block";
                    firstshown = true;
                }
            }

             function setcounts(success, failed, warnings = 0){
                 const counts = document.querySelector(".counts");
                 counts.innerHTML = `<a style="color:#6cf16c">${success} success</a>//<a style="color:#fff457">${warnings} warnings</a>//<a style="color:#f08b8b">${failed} failed</a>`;
             }

             function errorlog(msg){
                 const now = new Date().toISOString().replace("T"," ").replace("Z","");
                 errors.textContent += "[" + now + "] " + msg + "\n";
                 errors.scrollTop = errors.scrollHeight;
             }

             function idgen() {
                 const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                 let result = '';
                 for (let i = 0; i < 3; i++) {
                     result += chars.charAt(Math.floor(Math.random() * chars.length));
                 }; return result;
             }

             function savefile(blob, filename) {
                 const url = URL.createObjectURL(blob);
                 const a = document.createElement("a");
                 a.href = url; a.download = filename;
                 document.body.appendChild(a);
                 a.click(); document.body.removeChild(a);
                 URL.revokeObjectURL(url);
             }

            function rgbatoblob(width, height, pixels){
                const canvas = document.createElement("canvas");
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext("2d");
                const imageData = new ImageData(new Uint8ClampedArray(pixels.buffer), width, height);
                ctx.putImageData(imageData, 0, 0);
                return new Promise((resolve, reject) => {
                    canvas.toBlob((blob) => {
                        if (blob) resolve(blob); else reject(new Error("PNG encoding failed"));
                    }, "image/png");
                });
            }

            async function runcode(){
                if (!pyready){
                    pyready = (async () => {
                        const py = await loadPyodide({indexURL: "https://cdn.jsdelivr.net/pyodide/v0.28.3/full/"});
                        
                        // extremely infuriating workaround to use python on web instead of plain js.
                        // there are absolutely NO practical solutions of decompressing both of these..
                        // this might not work at all for many people, and for that i'm sorry

                        await py.loadPackage("micropip");
                        await py.runPythonAsync(`
                            import micropip
                            await micropip.install("zstandard")
                        `);

                        // (no indent or it'll break)
                        const thething = `
import zlib
import zstandard as zstd

def decryptrawpy(data):
    if hasattr(data, "tobytes"):
        data = data.tobytes()
    elif not isinstance(data, bytes):
        data = bytes(data)
    
    if len(data) < 6:
        raise ValueError("file too small")
    
    pixels = None
    width = height = 0
    
    non_zero_count = sum(1 for b in data[:1000] if b != 0)
    total_non_zero = sum(1 for b in data if b != 0)
    
    if len(data) >= 16:
        header_bytes = data[:16]
        
        possible_dims = []
        
        for i in range(0, 12, 2):
            if i + 2 <= len(data):
                val = int.from_bytes(data[i:i+2], "little")
                if 16 <= val <= 4096:
                    possible_dims.append(val)
        
        if len(possible_dims) >= 2:
            for i in range(len(possible_dims)):
                for j in range(i+1, len(possible_dims)):
                    w, h = possible_dims[i], possible_dims[j]
                    pixel_count = w * h
                    expected_bytes = pixel_count * 4
                    
                    
                    if expected_bytes <= len(data) and expected_bytes > len(data) * 0.5:
                        pixel_data = data[:expected_bytes]
                        pixels = pixel_data
                        width, height = w, h
                        
                        rgba_pixels = bytearray(pixels)
                        for i in range(0, len(rgba_pixels), 4):
                            if i + 3 < len(rgba_pixels):
                                rgba_pixels[i], rgba_pixels[i+2] = rgba_pixels[i+2], rgba_pixels[i]
                        
                        return {"width": width, "height": height, "pixels": bytes(rgba_pixels), "used_fallback": False}
    
    if non_zero_count > 100 or total_non_zero > len(data) * 0.1:
        pixel_data = data
        
        if len(pixel_data) % 4 == 0:
            pixel_count = len(pixel_data) // 4
            
            import math
            factors = []
            for i in range(1, int(math.sqrt(pixel_count)) + 1):
                if pixel_count % i == 0:
                    factors.append((i, pixel_count // i))
                    if i != pixel_count // i:
                        factors.append((pixel_count // i, i))
            
            factors.sort(key=lambda x: abs(x[0] - x[1]))
            
            for w, h in factors:
                if 16 <= w <= 4096 and 16 <= h <= 4096 and w * h == pixel_count:
                    aspect_ratio = max(w, h) / min(w, h)
                    if aspect_ratio <= 8:
                        width, height = w, h
                        pixels = pixel_data
                        break
            
            if pixels is not None:
                rgba_pixels = bytearray(pixels)
                for i in range(0, len(rgba_pixels), 4):
                    if i + 3 < len(rgba_pixels):
                        rgba_pixels[i], rgba_pixels[i+2] = rgba_pixels[i+2], rgba_pixels[i]
                
                return {"width": width, "height": height, "pixels": bytes(rgba_pixels), "used_fallback": False}
    
    zstd_magic = bytes((0x28, 0xB5, 0x2F, 0xFD))
    zstd_start = data.find(zstd_magic)
    
    zlib_start = -1
    for i in range(len(data)-1):
        cmf = data[i]
        if cmf == 0x78:
            flg = data[i+1]
            if ((cmf * 256) + flg) % 31 == 0:
                zlib_start = i
                break
    
    decompressed_data = None
    compression_type = None
    
    if zstd_start != -1:
        payload = data[zstd_start:]
        try:
            dctx = zstd.ZstdDecompressor()
            decompressed_data = dctx.decompress(payload)
            compression_type = "zstd"
        except Exception as e:
            pass
    
    if decompressed_data is None and zlib_start != -1:
        payload = data[zlib_start:]
        try:
            decompressed_data = zlib.decompress(payload)
            compression_type = "zlib"
        except Exception as e:
            pass
    
    if decompressed_data is None:
        for offset in range(0, len(data) - 100, 100):
            if offset + 100 <= len(data):
                if data[offset:offset+4] == zstd_magic:
                    payload = data[offset:]
                    try:
                        dctx = zstd.ZstdDecompressor()
                        decompressed_data = dctx.decompress(payload)
                        compression_type = "zstd"
                        break
                    except Exception as e:
                        pass
                
                if offset + 1 < len(data) and data[offset] == 0x78:
                    flg = data[offset+1]
                    if ((data[offset] * 256) + flg) % 31 == 0:
                        payload = data[offset:]
                        try:
                            decompressed_data = zlib.decompress(payload)
                            compression_type = "zlib"
                            break
                        except Exception as e:
                            print(f"zlib decompression failed at offset {offset}: {e}")
        
        if decompressed_data is None and len(data) >= 16:
            header_bytes = data[:16]
            
            for i in range(4, 16, 2):
                if i + 2 <= len(data):
                    offset = int.from_bytes(data[i:i+2], "little")
                    if 0 < offset < len(data) - 100:
                        if offset + 4 <= len(data) and data[offset:offset+4] == zstd_magic:
                            payload = data[offset:]
                            try:
                                dctx = zstd.ZstdDecompressor()
                                decompressed_data = dctx.decompress(payload)
                                compression_type = "zstd"
                                break
                            except Exception as e:
                                print(f"zstd decompression failed at header offset {offset}: {e}")
                        
                        if offset + 1 < len(data) and data[offset] == 0x78:
                            flg = data[offset+1]
                            if ((data[offset] * 256) + flg) % 31 == 0:
                                payload = data[offset:]
                                try:
                                    decompressed_data = zlib.decompress(payload)
                                    compression_type = "zlib"
                                    break
                                except Exception as e:
                                    print(f"zlib decompression failed at header offset {offset}: {e}")
        
        if decompressed_data is None:
            raise ValueError("could not decompress data with zstd or zlib")
    
    pixel_count = len(decompressed_data) // 4
    if len(decompressed_data) % 4 != 0:
        raise ValueError(f"decompressed data size {len(decompressed_data)} is not divisible by 4")
    
    pixels = None
    width = height = 0
    
    # method 1
    width_height_candidates = []
    
    if len(data) >= 10:
        width_height_candidates.extend([
            (int.from_bytes(data[2:4], "little"), int.from_bytes(data[4:6], "little")),
            (int.from_bytes(data[6:8], "little"), int.from_bytes(data[8:10], "little")),
        ])
    
    for offset in range(0, min(20, len(data) - 8)):
        if offset + 8 <= len(data):
            w1 = int.from_bytes(data[offset:offset+2], "little")
            h1 = int.from_bytes(data[offset+2:offset+4], "little")
            w2 = int.from_bytes(data[offset+4:offset+6], "little")
            h2 = int.from_bytes(data[offset+6:offset+8], "little")
            width_height_candidates.extend([(w1, h1), (w2, h2)])
            
            if offset + 8 <= len(data):
                w32 = int.from_bytes(data[offset:offset+4], "little")
                h32 = int.from_bytes(data[offset+4:offset+8], "little")
                width_height_candidates.extend([(w32, h32)])
    
    for offset in range(0, min(20, len(data) - 8)):
        if offset + 8 <= len(data):
            w1 = int.from_bytes(data[offset:offset+2], "big")
            h1 = int.from_bytes(data[offset+2:offset+4], "big")
            w2 = int.from_bytes(data[offset+4:offset+6], "big")
            h2 = int.from_bytes(data[offset+6:offset+8], "big")
            width_height_candidates.extend([(w1, h1), (w2, h2)])
            
            if offset + 8 <= len(data):
                w32 = int.from_bytes(data[offset:offset+4], "big")
                h32 = int.from_bytes(data[offset+4:offset+8], "big")
                width_height_candidates.extend([(w32, h32)])
    
    width_height_candidates = list(set([(w, h) for w, h in width_height_candidates 
                                      if w > 0 and h > 0 and w < 50000 and h < 50000]))
    
    def dimension_score(w, h):
        common_dims = [(320, 480), (480, 800), (640, 480), (800, 480), (480, 320), (480, 640),
                       (1024, 768), (768, 1024), (1280, 720), (720, 1280), (1920, 1080), (1080, 1920),
                       (2048, 2048), (1024, 1024), (512, 512), (256, 256), (4096, 4096)]
        if (w, h) in common_dims:
            return 100
        
        if w >= 2048 or h >= 2048:
            aspect_ratio = max(w, h) / min(w, h)
            if aspect_ratio <= 2:
                return 90
            elif aspect_ratio <= 4:
                return 80
            else:
                return 60
        
        w_score = 10 if w % 16 == 0 else 5 if w % 8 == 0 else 1
        h_score = 10 if h % 16 == 0 else 5 if h % 8 == 0 else 1
        aspect_ratio = max(w, h) / min(w, h)
        aspect_penalty = max(0, (aspect_ratio - 3) * 2)
        return w_score + h_score - aspect_penalty
    
    valid_header_candidates = [(w, h) for w, h in width_height_candidates 
                              if w * h == pixel_count and 
                                 w >= 16 and h >= 16 and
                                 max(w, h) / min(w, h) <= 10 and
                                 w <= 8192 and h <= 8192]
    valid_header_candidates.sort(key=lambda x: dimension_score(x[0], x[1]), reverse=True)
    
    for w, h in valid_header_candidates:
        pixels = decompressed_data
        width, height = w, h
        break
    
    # method 2 (fallback which almost always leaves corrupted images)
    used_fallback = False
    if pixels is None:
        common_ratios = [(480, 800), (320, 480), (800, 480), (480, 320), (640, 480), (480, 640), 
                         (720, 1280), (1280, 720), (1080, 1920), (1920, 1080), (1024, 768), (768, 1024),
                         (2048, 2048), (1024, 1024), (512, 512), (256, 256), (4096, 4096), (2048, 1024), (1024, 2048)]
        
        for w, h in common_ratios:
            if w * h == pixel_count:
                pixels = decompressed_data
                width, height = w, h
                used_fallback = True
                break
    
    # method 3
    if pixels is None:
        import math
        factors = []
        for i in range(1, int(math.sqrt(pixel_count)) + 1):
            if pixel_count % i == 0:
                factors.append((i, pixel_count // i))
                if i != pixel_count // i:
                    factors.append((pixel_count // i, i))
        
        def reasonableness_score(w, h):
            aspect_ratio = max(w, h) / min(w, h)
            width_multiple = 1 if w % 16 == 0 else 0.5 if w % 8 == 0 else 0.1
            height_multiple = 1 if h % 16 == 0 else 0.5 if h % 8 == 0 else 0.1
            return width_multiple + height_multiple - (aspect_ratio - 1) * 0.1
        
        reasonable_factors = [(w, h) for w, h in factors 
                             if 16 <= w <= 50000 and 16 <= h <= 50000 and w * h == pixel_count]
        reasonable_factors.sort(key=lambda x: reasonableness_score(x[0], x[1]), reverse=True)
        
        for w, h in reasonable_factors:
            pixels = decompressed_data
            width, height = w, h
            break
    
    if pixels is None:
        error_msg = f"could not find valid dimensions for {pixel_count} pixels"
        error_msg += f", decompressed {len(decompressed_data)} bytes using {compression_type}"
        error_msg += f", tried {len(width_height_candidates)} header candidates: {width_height_candidates[:5]}"
        raise ValueError(error_msg)
    
    return {"width": width, "height": height, "pixels": pixels, "used_fallback": used_fallback}
`;
                        await py.runPythonAsync(thething);
                        return py;
                    })();
                }; return pyready;
            }

            async function decryptfile(file){
                showstats();
                const py = await runcode();
                const buf = new Uint8Array(await file.arrayBuffer());
                
                const decryptfunction = py.globals.get("decryptrawpy");
                
                const result = await decryptfunction(py.toPy(buf));
                const r = result.toJs({ create_proxies: false });
                const width = r.width;
                const height = r.height;
                const pixels = new Uint8Array(r.pixels);
                const used_fallback = r.used_fallback;
                const blob = await rgbatoblob(width, height, pixels);
                return { blob, used_fallback };
            }

            /*//////////////////////////////////////////////////////////////////////*/

            // brokey
            async function decryptsplitfile(files){
                showstats();
                const py = await runcode();
                
                const mainfiles = files.filter(file => {
                    const name = file.name.toLowerCase();
                    if (name.endsWith('.raw') && !name.match(/\.raw\d+$/)) {
                        return true;
                    }
                    if (name.match(/\.raw\d+$/) && file.size > 100) {
                        return true;
                    }
                    return false;
                });
                
                const splitfiles = files.some(file => {
                    const name = file.name.toLowerCase();
                    return name.match(/\.raw\d+$/);
                });
                
                if (splitfiles && !splitwarnshown) {
                    document.querySelector('.splitwarn').style.display = 'flex';
                    splitwarnshown = true;
                }
                
                if (mainfiles.length > 1) {
                    const raw1files = mainfiles.filter(f => f.name.toLowerCase().match(/\.raw\d+$/));
                    if (raw1files.length > 0) {
                        const totalsize = mainfiles.reduce((sum, f) => sum + f.size, 0);
                        if (totalsize > 500000) {
                            const largerawfiles = raw1files.filter(f => f.size > 1000);
                            try {
                                const buffers = [];
                                for (const file of largerawfiles) {
                                    const buf = new Uint8Array(await file.arrayBuffer());
                                    buffers.push(buf);
                                }
                                const totalbufsize = buffers.reduce((sum, buf) => sum + buf.length, 0);
                                const combinedbuffer = new Uint8Array(totalbufsize);
                                let offset = 0;
                                for (const buf of buffers) {
                                    combinedbuffer.set(buf, offset);
                                    offset += buf.length;
                                }
                                const result = await pyodide.runPython(`
                                    result = decryptrawpy(${combinedbuffer})
                                    result
                                `);
                                
                            if (result && result.width && result.height) {
                                const blob = await rgbatoblob(result.width, result.height, new Uint8Array(result.pixels));
                                return { blob, used_fallback: false, warning: "Split file conversion - may have incorrect colors/dimensions" };
                            }
                            } catch (e) {
                            }
                        }; const testfile = raw1files[0];
                        
                        try {
                            const testbuf = new Uint8Array(await testfile.arrayBuffer());
                            const result = await pyodide.runPython(`
                                result = decryptrawpy(${testbuf})
                                result
                            `);
                            
                            if (result && result.width && result.height) {
                                const blob = await rgbatoblob(result.width, result.height, new Uint8Array(result.pixels));
                                return { blob, used_fallback: false, warning: "Split file conversion - may have incorrect colors/dimensions" };
                            }
                        } catch (e) {}
                    }
                    
                    mainfiles.sort((a, b) => {
                        const aname = a.name.toLowerCase();
                        const bname = b.name.toLowerCase();
                        
                        if (aname.endsWith('.raw') && !bname.endsWith('.raw')) return -1;
                        if (!aname.endsWith('.raw') && bname.endsWith('.raw')) return 1;
                        if (aname.endsWith('.raw') && bname.endsWith('.raw')) return 0;
                        
                        const anum = parseInt(aname.match(/\.raw(\d+)$/)?.[1] || '0');
                        const bnum = parseInt(bname.match(/\.raw(\d+)$/)?.[1] || '0');
                        return anum - bnum;
                    });
                }
            
                const buffers = [];
                for (const file of mainfiles) {
                    const buf = new Uint8Array(await file.arrayBuffer());
                    buffers.push(buf);
                }

                const totallength = buffers.reduce((sum, buf) => sum + buf.length, 0);
                const combinedbuffer = new Uint8Array(totallength);
                let offset = 0;
                for (const buf of buffers) {
                    combinedbuffer.set(buf, offset);
                    offset += buf.length;
                }
                
                const decryptfunction = py.globals.get("decryptrawpy");
                
                const result = await decryptfunction(py.toPy(combinedbuffer));
                const r = result.toJs({ create_proxies: false });
                const width = r.width;
                const height = r.height;
                const pixels = new Uint8Array(r.pixels);
                const used_fallback = r.used_fallback;
                const blob = await rgbatoblob(width, height, pixels);
                
                const warning = splitfiles ? "Split file conversion - likely has incorrect colors/dimensions" : null;
                
                return {blob, used_fallback, warning};
            }

            /*//////////////////////////////////////////////////////////////////////*/

            function replaceext(name, newExt){
                const i = name.lastIndexOf(".");
                return (i === -1 ? name : name.slice(0, i)) + newExt;
            }

            async function handlefolder(files){
                let success = 0;
                let failed = 0;
                let warnings = 0;
                setcounts(success, failed, warnings);
                progressinfo.textContent = "Preparing…";

                const rawfiles = Array.from(files).filter(f => {
                    const name = f.name.toLowerCase();
                    return name.endsWith(".raw") || name.match(/\.raw\d+$/);
                });
                if (rawfiles.length === 0){
                    progressinfo.textContent = "No .raw files found... (Are you sure you selected the right folder?)";
                    return;
                }
                
                const allfiles = Array.from(files);
                const potentialsplitfiles = allfiles.filter(f => {
                    const name = f.name.toLowerCase();
                    return name.includes('raw') || 
                           name.match(/\.\d+$/) /* ||
                           // name.match(/\.part\d+$/); */
                });

                const zip = new JSZip();
                const filegroups = new Map();
                for (const file of rawfiles) {
                    const name = file.name.toLowerCase();
                    let basename;
                    
                    if (name.endsWith('.raw')) {
                        basename = name.slice(0, -4);
                    } else if (name.match(/\.raw\d+$/)) {
                        basename = name.replace(/\.raw\d+$/, '');
                    } else {
                        continue;
                    }
                    
                    if (!filegroups.has(basename)) {
                        filegroups.set(basename, []);
                    }
                    filegroups.get(basename).push(file);
                }

                let processedcount = 0;
                const totalgroups = filegroups.size;

                for (const [basename, groupfiles] of filegroups) {
                    processedcount++;
                    const rel = groupfiles[0].webkitRelativePath || groupfiles[0].name;
                    progressinfo.textContent = `Processing (${processedcount}/${totalgroups}): ${basename}`;
                    
                    try {
                        groupfiles.sort((a, b) => {
                            const aname = a.name.toLowerCase();
                            const bname = b.name.toLowerCase();
                            
                            if (aname.endsWith('.raw') && !bname.endsWith('.raw')) return -1;
                            if (!aname.endsWith('.raw') && bname.endsWith('.raw')) return 1;
                            if (aname.endsWith('.raw') && bname.endsWith('.raw')) return 0;
                            
                            const anum = parseInt(aname.match(/\.raw(\d+)$/)?.[1] || '0');
                            const bnum = parseInt(bname.match(/\.raw(\d+)$/)?.[1] || '0');
                            return anum - bnum;
                        });

                        const result = await decryptsplitfile(groupfiles);
                        const targetpath = rel.replace(/\\/g,"/").replace(/\.[Rr][Aa][Ww]\d*$/, "") + ".png";
                        zip.file(targetpath, result.blob);
                        
                        if (result.warning) {
                            warnings++;
                            errorlog(`${basename} - ${result.warning}`);
                        } else if (result.used_fallback) {
                            warnings++;
                            errorlog(`${basename} - used fallback dimensions (will likely be corrupted)`);
                        } else {
                            success++;
                        }
                    } catch (e){
                        failed++;
                        errorlog(basename + ": " + (e && e.message ? e.message : e));
                    }
                    setcounts(success, failed, warnings);
                }

                 progressinfo.textContent = "Zipping results…";
                 const zipblob = await zip.generateAsync({type: "blob", compression: "DEFLATE"});
                 const uniqueid = idgen();
                 savefile(zipblob, `FeedwithCandy_${uniqueid}.zip`);
                 progressinfo.textContent = "Done! Remember to rename .pngs back to .raws after editing.";
            }

            async function handlesingle(file){
                setcounts(0, 0, 0);
                progressinfo.textContent = "Decrypting single file...";
                 try {
                     const result = await decryptfile(file);
                     const outname = replaceext(file.name, ".png");
                     savefile(result.blob, outname);
                     
                     if (result.used_fallback) {
                         setcounts(0, 0, 1);
                         errorlog(`${file.name} - used fallback dimensions (will likely be corrupted)`);
                         progressinfo.textContent = "Done with warnings! Check errors for details.";
                     } else {
                         setcounts(1, 0, 0);
                         progressinfo.textContent = "Done! Remember to rename .png back to .raw after editing.";
                     }
                 } catch (e){
                    setcounts(0, 1, 0);
                    errorlog("fail: " + file.name + (e && e.message ? e.message : e));
                    progressinfo.textContent = "Failed... If this is a split file, try selecting the folder containing all .raw files instead.";
                }
            }

            document.querySelector(".inputfolder").addEventListener("change", async (e) => {
                if (!e.target.files || e.target.files.length === 0) return;
                await handlefolder(e.target.files);
                document.querySelector(".inputfolder").value = "";
            });
            document.querySelector(".inputsingle").addEventListener("change", async (e) => {
                if (!e.target.files || e.target.files.length === 0) return;
                await handlesingle(e.target.files[0]);
                document.querySelector(".inputsingle").value = "";
            });

        })();
    </script>

</body>
</html>